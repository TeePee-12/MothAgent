<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MothAgent API documentation</title>
<meta name="description" content="Created on Fri Apr 5 14:39:22 2024
@author: Thomas â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MothAgent</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Apr 5 14:39:22 2024
@author: Thomas</p>
<p>This module defines the MothAgent class which handles autonomous movement and luminosity detection
in a grid-based environment. The agent is designed to navigate and find bright areas efficiently.</p>
<p>This module is designed to operate on a Sphero BOLT using the spheroV2 SDK Module - passed as Droid.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Apr 5 14:39:22 2024
@author: Thomas

This module defines the MothAgent class which handles autonomous movement and luminosity detection 
in a grid-based environment. The agent is designed to navigate and find bright areas efficiently.

This module is designed to operate on a Sphero BOLT using the spheroV2 SDK Module - passed as Droid.
&#34;&#34;&#34;

from spherov2.types import Color
import time
import math
import os
import sys

class MothAgent:
    &#34;&#34;&#34;
    Represents an autonomous agent that navigates a grid-based environment to find areas with high luminosity.

    Attributes:
        droid: A robotic agent instance - sphero BOLT from the spherov2 module.
        bounds (tuple): Centimetres - Grid boundaries as (width, height), virtual walls of the search area.
        grid_size (int): Centimetres -Size of each grid cell.
        environment (dict): Representation of the entire environment, 
        environment[key] is a tuple representing (x,y) locations of the grid.
        environment[val] is a tuple represetning the state of that location
        (visited,lum) where visitied is 0 if not visited or 1 if visited, and lum is the recorded brightness.
        frontier (list): The search frontier used by the searching algorithms.
        done (bool): Indicates terminal state, defaults to False, is set to True when terminal state reached.
        lum (float): Luminosity reading in the current state.
        max_lum (float): Highest luminosity encountered.
        brightest_loc (tuple): Coordinates of the brightest cell found.
        log (file): Data logging file name.
    &#34;&#34;&#34;
    
    def __init__(self, droid, bounds, grid_size, log_file):
        &#34;&#34;&#34;
        Initialises the agent with the specified robotic interface, environment boundaries, grid size, and log file.
        Takes care of constrruction the environment dictionary, and setting the current state variables at the 0th timestep.
        Opens the logging file and writes the column headers.
        &#34;&#34;&#34;
        self.bounds = bounds
        self.grid_size = grid_size
        self.droid = droid
        
        self.x = int(self.droid.get_location()[&#39;x&#39;] / self.grid_size)
        self.y = int(self.droid.get_location()[&#39;y&#39;] / self.grid_size)
        self.environment = {(x, y): (0, 0) for x in range(bounds[0] // grid_size) for y in range(bounds[1] // grid_size)}

        self.frontier = [(self.x, self.y)]
        
        self.done = False
        
        self.lum = 0
        self.max_lum = 0
        self.brightest_loc = (self.x, self.y)
        
        self.time_step = 0
        self.log_file = log_file
        with open(self.log_file, &#39;w&#39;) as file:
            file.write(&#34;time, timestep, x, y, lum\n&#34;)
        
    def transition_function(self, action, timeout=15):
        &#34;&#34;&#34;
        Executes the agenttransition function actions with a timeout mechanism
        to prevent operations from hanging indefinitely.
        
        Parameters
        ----------
        action: tuple
            The action ((x,y)location) - parameter to be passed to the move_to_point method.
        timeout: int 
            Default = 15. The maximum time (in seconds) allowed for for transition before timing out.
        
        Raises
        ------
        Exception: If the transition function failed to move or update state due to environmental factors.
        
        Returns
        -------
        None. Calls functions to directly set state variables and move the droid.
        &#34;&#34;&#34;
        self.time_step += 1
        
        if not self.move_to_point(action, timeout):
            raise Exception(&#34;Error in transition function - unable to move to next state.&#34;)
        if not self.update_agent_state():
            raise Exception(&#34;Error in transition function - unable to update state variable.&#34;)

    def update_agent_state(self):
        &#34;&#34;&#34; 
        Part of the transition function of the agent. 
        Directly updates the state variables: x, y, lum, environment, max_lum and brightest_loc.
        
        Returns
        -------
        Bool: 
            True if state was update successfully else false.
        &#34;&#34;&#34;
        new_lum = self.get_lum()
        if new_lum == None:
            return False
        self.lum = new_lum
        if self.lum &gt; (self.max_lum or 0):
            self.max_lum = self.lum
            self.brightest_loc = (self.x, self.y)
            
        self.x = int(self.droid.get_location()[&#39;x&#39;] / self.grid_size)
        self.y = int(self.droid.get_location()[&#39;y&#39;] / self.grid_size)
        self.environment[(self.x, self.y)] = (1, self.lum)

        self.data_log()
        
        return True
    
    def get_lum(self, retry_count=0):
        &#34;&#34;&#34;
        Forms part of the transition function.
        Measures and returns the average luminosity from multiple readings.
        Handles potentially invalid readings through recursive calls.
        
        Parameters
        ----------
        retry_count: int
            Maximum allowable recursion depth when handling bad data.
        
        Returns
        -------
        lum : int
            Integer value of the lum reading, or None in case of bad data
        &#34;&#34;&#34;
        if retry_count &gt;5:
            return None
        
        lum_readings = []
        for _ in range(10):
            lum_readings.append(self.droid.get_luminosity()[&#39;ambient_light&#39;])
            #self.droid.spin(36, 0.1)
            time.sleep(0.01)
        avg_lum = sum(lum_readings) // len(lum_readings)
        
        #Sphero BOLT likes to retun nonesense data, recursively call this function in case of nonsense.
        if avg_lum &lt; 0:
            time.sleep(0.5)
            avg_lum = self.get_lum(retry_count+1)
        return avg_lum
        
    def move_to_point(self, waypoint, max_time=30):
        &#34;&#34;&#34;
        Part of the transition function of the agent.
        Moves the agent to the specified grid point.
        Updates the agents state variables upon reaching the new state.
        Gracefully handles faulty data fed from the spherov2 SDK and Sphero BOLT robot acting as droid.
        Will return false and &#34;give up&#34; after max_time seconds.
        
        Parameters
        ----------
        max_time: int (seconds)
            Defaults to 15 - time after whcih the function will break and return false.
        
        Returns
        -------
        Boolean. True if sucesfully reached the location, otherwise returns false to indicate a failure.
        &#34;&#34;&#34;
        target_x = (waypoint[0] * self.grid_size) + (self.grid_size * 0.5)
        target_y = (waypoint[1] * self.grid_size) + (self.grid_size * 0.5)
        
        #Retry counters for handling bad data from sphero
        retry_count = 0
        max_retries = 5
        
        #timers for preventing infinite hangups if the sphero gets stuck
        start = time.time()
        elapsed=time.time()
        
        while elapsed &lt; start + max_time: 
            elapsed=time.time()
            location = self.droid.get_location()
            x = location[&#39;x&#39;]
            y = location[&#39;y&#39;]
            if math.isnan(x) or math.isnan(y):
                if retry_count &lt; max_retries:
                    time.sleep(0.5)
                    retry_count += 1
                    continue
                else:
                    print(&#34;Failed to get valid location data after several retries.&#34;)
                    return False

            dist_error = math.sqrt((x - target_x)**2 + (y - target_y)**2)
            theta_error = 180 * math.atan2(target_x - x, target_y - y) / math.pi
            self.droid.set_heading(int(theta_error))
    
            try:
                if dist_error &gt; 10:
                    self.droid.set_speed(45)
                elif dist_error &lt; 5:
                    self.droid.set_speed(0)
                    return True
                else:
                    self.droid.set_speed(int(dist_error) + 10)
                time.sleep(0.01)
            except ValueError as e:
                print(f&#34;Error in setting heading: {e}&#34;)
                return False
        return False


    def get_valid_actions(self, x, y):
        &#34;&#34;&#34;
        A utility to the searching algorithms.
        Generates a set of possible allowable actions for navigation of the grid
        environemnt from a location (x,y).
        For the use of this function, re-visiting already visited locations is
        considred to be invalid and not allowable.
        
        Parameters
        ----------
        x: int
            X co-ordinate of the queried location
        y: int
            Y co-ordinate of the queried location
        
        Returns
        -------
        valid_actions: array
            An array containing all valid actions from the queried location given the current environment state.
        &#34;&#34;&#34;
        valid_actions = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x, new_y = x + dx, y + dy
                if (new_x, new_y) in self.environment and self.environment[(new_x, new_y)][0] == 0:
                    valid_actions.append((new_x, new_y))
        return valid_actions

    def brightest_adjacent_cell(self, cell):
        &#34;&#34;&#34;
        A utility to the searching algorithms.
        Identifies the brightest among the adjacent cells of a given cell.
        If the queried cell is brighter than all it&#39;s adjacent cells then 
        the queried cell location will be returned.
        
        Parameters
        ----------
        cell : Tuple
            (x,y) co ordinates of a queried location

        Returns
        -------
        brightest : Tuple.
            (x,y) co-ordinates of the brightest cell adjacent to the queried cell.
        &#34;&#34;&#34;
        brightest = (cell[0],cell[1])
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x, new_y = cell[0] + dx, cell[1] + dy
                if (new_x, new_y) in self.environment:
                    if self.environment[(new_x, new_y)][1] &gt; self.environment[brightest][1]:
                        brightest = (new_x, new_y)
        return brightest

    def depth_first_search(self, threshold):
        &#34;&#34;&#34;
        Perform a depth-first search of the environment.
        Frontier is used as a stack, or single ended queue in this instance.
        Algorithm takes the following steps:
            -Find valid actions at the current state.
            -Push these actions to the frontier.
            -Pop the top action from the frontier.
            -Call the transition function (move_to_point()) with the new action.
            -Cointinue until a specified threshold value is discovered.
        
        The way that valid actions are returned and pushed to the stack results in
        the agent preffering to travel diagonally to extreme points of the environment first.
        
        The search continues until one of the two conditions are met: 
            - A location with luminosity greater than the specified threshold has been found.
            - The entire environment has been searched.
            
        Parameters
        ----------
        threshold: int
            A threshold luminosity reading value to triger breaking out of the search.
            
        Returns
        -------
        None. Calls the transition function (move_to_point()) from within.
        &#34;&#34;&#34;
        self.set_lights(&#39;searching&#39;)
        
        self.frontier = []
        while self.max_lum &lt; threshold:
                
            self.print_grid()
            print(&#34;getting valid_actions&#34;)
            valid_actions = self.get_valid_actions(self.x, self.y)
            print(valid_actions)
            #input(&#34;Agent Paused, Press Enter to Carry on...&#34;)
            if valid_actions:
                print(&#34;Valid Actions Found, Updating Frontier&#34;)
                self.frontier.extend([action for action in valid_actions if action not in self.frontier])
            if self.frontier:
                print(f&#34;New Frontier: \n{self.frontier}&#34;)
                new_node = self.frontier.pop()
                self.move_to_point(new_node)
                self.update_agent_state()
            else:
                print(&#34;We would break the search here&#34;)
                #break

    def optimised_greedy_search(self):
        &#34;&#34;&#34;
        Perform a Greedy search exploration of the environemnt.
        At each step the agent moves in the direction that has the brightest location.
        Algorithm takes the following steps:
            -Given current search location (x,y) determine the valid actions.
            -Take each valid action and update the state variabls for each new state,action.
            -Once all adjacent cells have been visited, determine which adjacent cell to the search location is the brightest.
            -Travel to the brightest location and repreat.
            -If the curent search location is the brightest the terminal state has been reached
            -Set self.done = True
        
        This approach is optimised in the sense that it uses the known luminosity data of previously 
        visited cells to make informed decisions quickly, thus minimizing unnecessary exploration.

        Returns:
            None. Calls the transition function (move_to_point()) from within. Will directly set self.done to True.
        &#34;&#34;&#34;
        self.set_lights(&#39;localising&#39;)
        
        maximum = (self.x, self.y)
        
        while not self.done:
            self.print_grid()
            print(&#34;getting valid_actions&#34;)
            valid_actions = self.get_valid_actions(self.x, self.y)
            print(valid_actions)
            #input(&#34;Agent Will Visit adjecent Cells, Press Enter to Carry on...&#34;)
            for action in valid_actions:
                self.transition_function(action)
                self.print_grid()
            #input(&#34;Agent Will now compute the brightest adjacent cell and drive there, Press Enter to Carry on...&#34;)
            brightest = self.brightest_adjacent_cell(maximum)
            self.transition_function(brightest)
            if maximum == brightest:
                print(f&#34;Lamp found at {brightest} with luminosity {self.environment[brightest][1]}&#34;)
                self.done = True
            maximum = brightest

    def coverage(self):
        &#34;&#34;&#34;
        This is one of the top level callable search algorithms that the agent may employ.Executes a sweeping coverage of the environment in a snake-like, zigzag pattern to ensure all areas are visited.
        This method will set the self.done variable to True upon reaching the terminal state.
   
        Returns:
        None. The agent&#39;s state and the map of the environment are updated internally to reflect the progress of the search.
        &#34;&#34;&#34;
        self.set_lights(&#39;coverage&#39;)
        zigzag = True
        self.update_agent_state()
        while any(value[0] == 0 for value in self.environment.values()):
            self.print_grid()
            if zigzag:
                if self.y &lt; (self.bounds[1] / self.grid_size) - 1:
                    new_target = (self.x, self.y + 1)
                    print(&#34;moving North&#34;)
                elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                    new_target = (self.x + 1, self.y)
                    zigzag = False
                else:
                    print(&#34;Edge of the Universe.&#34;)
            else:
                if self.y &gt; 0:
                    new_target = (self.x, self.y - 1)
                    print(&#34;Moving South&#34;)
                elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                    new_target = (self.x + 1, self.y)
                    zigzag = True
                else:
                    print(&#34;Edge of the Universe.&#34;)
            self.transition_function(new_target)
        
        max_lum_location = max(self.environment, key=lambda k: self.environment[k][1])
        self.transition_function(max_lum_location)
        self.done = True

    def active_sensing(self, threshold = 100):
        &#34;&#34;&#34;
        Conducts an active sensing search of the environemnt.
        First conduction DFS until a threshhold luminosity is discovered.
        Then implements a greedy search to reach terminal state.
        Find the area of highest luminosity.
        
        Parameters
        ----------
        threshold : int
            
        
        &#34;&#34;&#34;
        self.update_agent_state()
        self.depth_first_search(threshold)
        print(f&#34;Greater than {threshold} found, switching to active sensing&#34;)
        self.optimised_greedy_search()    

    def data_log(self):
        &#34;&#34;&#34;
        Logs the agent&#39;s position, luminosity, and time step to a file.
        &#34;&#34;&#34;
        
        data = f&#34;{time.time_ns()}, {self.time_step}, {self.x}, {self.y}, {self.lum}\n&#34;
        with open(self.log_file, &#39;a&#39;) as file:
            file.write(data)

    def set_lights(self, style):
        &#34;&#34;&#34;
        A basic utility function to set the lights.
        Useful for instantaneous visul feedback of the agent&#39;s actions to an observer.
        
        Returns
        -------
        None. Directly sets the LED colours through the spheroV2 SDK.
        &#34;&#34;&#34;
        colours = {
            &#39;coverage&#39;: ((75, 0, 130),(0,0,0)),  # Purple
            &#39;searching&#39;: ((255, 140, 0),(0,0,0)), # Orange
            &#39;localising&#39;: ((0, 150, 0),(75,75,75)),  # Green
            &#39;party1&#39;: ((255, 0, 0),(0,0,255)),      # Red
            &#39;party2&#39;: ((0, 0, 255),(255,0,0))       # Blue
        }
        main_colour, small_colour = colours.get(style, ((0, 0, 0), (0, 0, 0)))

        self.droid.set_main_led(Color(main_colour[0], main_colour[1], main_colour[2]))
        self.droid.set_front_led(Color(small_colour[0], small_colour[1], small_colour[2]))
        self.droid.set_back_led(Color(small_colour[0], small_colour[1], small_colour[2]))

    def print_grid(self):
        &#34;&#34;&#34;
        Prints a visual representation of the grid environment, with blank squares for un-visited sites,
        and the measured luminosity for visited locations.
        Prints to the terminal using the maintained state variables
        
        returns
        -------
        none. Prints to the terminal.
        &#34;&#34;&#34;
        num_cells_x = self.bounds[0] // self.grid_size
        num_cells_y = self.bounds[1] // self.grid_size
    
        top_row = &#39; &#39; * 5 + &#39; &#39;.join(f&#39;{x:3d} &#39; for x in range(num_cells_x))
        print(top_row)
        horizontal_line = &#39; &#39; * 4 + &#39;+&#39; + (&#39;----+&#39; * num_cells_x)
        
        for y in reversed(range(num_cells_y)):
            print(horizontal_line)
            row = f&#39;{y:3d} |&#39;
            for x in range(num_cells_x):
                cell = (x, y)
                if self.environment.get(cell, (0, 0))[0] == 1:
                    brightness = int(self.environment[cell][1])
                    row += f&#39;{brightness:3d} |&#39;
                else:
                    row += &#39;    |&#39;
            print(row)
        print(horizontal_line)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MothAgent.MothAgent"><code class="flex name class">
<span>class <span class="ident">MothAgent</span></span>
<span>(</span><span>droid, bounds, grid_size, log_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an autonomous agent that navigates a grid-based environment to find areas with high luminosity.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>droid</code></strong></dt>
<dd>A robotic agent instance - sphero BOLT from the spherov2 module.</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Centimetres - Grid boundaries as (width, height), virtual walls of the search area.</dd>
<dt><strong><code>grid_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Centimetres -Size of each grid cell.</dd>
<dt><strong><code>environment</code></strong> :&ensp;<code>dict</code></dt>
<dd>Representation of the entire environment, </dd>
<dt>environment[key] is a tuple representing (x,y) locations of the grid.</dt>
<dt>environment[val] is a tuple represetning the state of that location</dt>
<dt>(visited,lum) where visitied is 0 if not visited or 1 if visited, and lum is the recorded brightness.</dt>
<dt><strong><code>frontier</code></strong> :&ensp;<code>list</code></dt>
<dd>The search frontier used by the searching algorithms.</dd>
<dt><strong><code>done</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates terminal state, defaults to False, is set to True when terminal state reached.</dd>
<dt><strong><code>lum</code></strong> :&ensp;<code>float</code></dt>
<dd>Luminosity reading in the current state.</dd>
<dt><strong><code>max_lum</code></strong> :&ensp;<code>float</code></dt>
<dd>Highest luminosity encountered.</dd>
<dt><strong><code>brightest_loc</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Coordinates of the brightest cell found.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>file</code></dt>
<dd>Data logging file name.</dd>
</dl>
<p>Initialises the agent with the specified robotic interface, environment boundaries, grid size, and log file.
Takes care of constrruction the environment dictionary, and setting the current state variables at the 0th timestep.
Opens the logging file and writes the column headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MothAgent:
    &#34;&#34;&#34;
    Represents an autonomous agent that navigates a grid-based environment to find areas with high luminosity.

    Attributes:
        droid: A robotic agent instance - sphero BOLT from the spherov2 module.
        bounds (tuple): Centimetres - Grid boundaries as (width, height), virtual walls of the search area.
        grid_size (int): Centimetres -Size of each grid cell.
        environment (dict): Representation of the entire environment, 
        environment[key] is a tuple representing (x,y) locations of the grid.
        environment[val] is a tuple represetning the state of that location
        (visited,lum) where visitied is 0 if not visited or 1 if visited, and lum is the recorded brightness.
        frontier (list): The search frontier used by the searching algorithms.
        done (bool): Indicates terminal state, defaults to False, is set to True when terminal state reached.
        lum (float): Luminosity reading in the current state.
        max_lum (float): Highest luminosity encountered.
        brightest_loc (tuple): Coordinates of the brightest cell found.
        log (file): Data logging file name.
    &#34;&#34;&#34;
    
    def __init__(self, droid, bounds, grid_size, log_file):
        &#34;&#34;&#34;
        Initialises the agent with the specified robotic interface, environment boundaries, grid size, and log file.
        Takes care of constrruction the environment dictionary, and setting the current state variables at the 0th timestep.
        Opens the logging file and writes the column headers.
        &#34;&#34;&#34;
        self.bounds = bounds
        self.grid_size = grid_size
        self.droid = droid
        
        self.x = int(self.droid.get_location()[&#39;x&#39;] / self.grid_size)
        self.y = int(self.droid.get_location()[&#39;y&#39;] / self.grid_size)
        self.environment = {(x, y): (0, 0) for x in range(bounds[0] // grid_size) for y in range(bounds[1] // grid_size)}

        self.frontier = [(self.x, self.y)]
        
        self.done = False
        
        self.lum = 0
        self.max_lum = 0
        self.brightest_loc = (self.x, self.y)
        
        self.time_step = 0
        self.log_file = log_file
        with open(self.log_file, &#39;w&#39;) as file:
            file.write(&#34;time, timestep, x, y, lum\n&#34;)
        
    def transition_function(self, action, timeout=15):
        &#34;&#34;&#34;
        Executes the agenttransition function actions with a timeout mechanism
        to prevent operations from hanging indefinitely.
        
        Parameters
        ----------
        action: tuple
            The action ((x,y)location) - parameter to be passed to the move_to_point method.
        timeout: int 
            Default = 15. The maximum time (in seconds) allowed for for transition before timing out.
        
        Raises
        ------
        Exception: If the transition function failed to move or update state due to environmental factors.
        
        Returns
        -------
        None. Calls functions to directly set state variables and move the droid.
        &#34;&#34;&#34;
        self.time_step += 1
        
        if not self.move_to_point(action, timeout):
            raise Exception(&#34;Error in transition function - unable to move to next state.&#34;)
        if not self.update_agent_state():
            raise Exception(&#34;Error in transition function - unable to update state variable.&#34;)

    def update_agent_state(self):
        &#34;&#34;&#34; 
        Part of the transition function of the agent. 
        Directly updates the state variables: x, y, lum, environment, max_lum and brightest_loc.
        
        Returns
        -------
        Bool: 
            True if state was update successfully else false.
        &#34;&#34;&#34;
        new_lum = self.get_lum()
        if new_lum == None:
            return False
        self.lum = new_lum
        if self.lum &gt; (self.max_lum or 0):
            self.max_lum = self.lum
            self.brightest_loc = (self.x, self.y)
            
        self.x = int(self.droid.get_location()[&#39;x&#39;] / self.grid_size)
        self.y = int(self.droid.get_location()[&#39;y&#39;] / self.grid_size)
        self.environment[(self.x, self.y)] = (1, self.lum)

        self.data_log()
        
        return True
    
    def get_lum(self, retry_count=0):
        &#34;&#34;&#34;
        Forms part of the transition function.
        Measures and returns the average luminosity from multiple readings.
        Handles potentially invalid readings through recursive calls.
        
        Parameters
        ----------
        retry_count: int
            Maximum allowable recursion depth when handling bad data.
        
        Returns
        -------
        lum : int
            Integer value of the lum reading, or None in case of bad data
        &#34;&#34;&#34;
        if retry_count &gt;5:
            return None
        
        lum_readings = []
        for _ in range(10):
            lum_readings.append(self.droid.get_luminosity()[&#39;ambient_light&#39;])
            #self.droid.spin(36, 0.1)
            time.sleep(0.01)
        avg_lum = sum(lum_readings) // len(lum_readings)
        
        #Sphero BOLT likes to retun nonesense data, recursively call this function in case of nonsense.
        if avg_lum &lt; 0:
            time.sleep(0.5)
            avg_lum = self.get_lum(retry_count+1)
        return avg_lum
        
    def move_to_point(self, waypoint, max_time=30):
        &#34;&#34;&#34;
        Part of the transition function of the agent.
        Moves the agent to the specified grid point.
        Updates the agents state variables upon reaching the new state.
        Gracefully handles faulty data fed from the spherov2 SDK and Sphero BOLT robot acting as droid.
        Will return false and &#34;give up&#34; after max_time seconds.
        
        Parameters
        ----------
        max_time: int (seconds)
            Defaults to 15 - time after whcih the function will break and return false.
        
        Returns
        -------
        Boolean. True if sucesfully reached the location, otherwise returns false to indicate a failure.
        &#34;&#34;&#34;
        target_x = (waypoint[0] * self.grid_size) + (self.grid_size * 0.5)
        target_y = (waypoint[1] * self.grid_size) + (self.grid_size * 0.5)
        
        #Retry counters for handling bad data from sphero
        retry_count = 0
        max_retries = 5
        
        #timers for preventing infinite hangups if the sphero gets stuck
        start = time.time()
        elapsed=time.time()
        
        while elapsed &lt; start + max_time: 
            elapsed=time.time()
            location = self.droid.get_location()
            x = location[&#39;x&#39;]
            y = location[&#39;y&#39;]
            if math.isnan(x) or math.isnan(y):
                if retry_count &lt; max_retries:
                    time.sleep(0.5)
                    retry_count += 1
                    continue
                else:
                    print(&#34;Failed to get valid location data after several retries.&#34;)
                    return False

            dist_error = math.sqrt((x - target_x)**2 + (y - target_y)**2)
            theta_error = 180 * math.atan2(target_x - x, target_y - y) / math.pi
            self.droid.set_heading(int(theta_error))
    
            try:
                if dist_error &gt; 10:
                    self.droid.set_speed(45)
                elif dist_error &lt; 5:
                    self.droid.set_speed(0)
                    return True
                else:
                    self.droid.set_speed(int(dist_error) + 10)
                time.sleep(0.01)
            except ValueError as e:
                print(f&#34;Error in setting heading: {e}&#34;)
                return False
        return False


    def get_valid_actions(self, x, y):
        &#34;&#34;&#34;
        A utility to the searching algorithms.
        Generates a set of possible allowable actions for navigation of the grid
        environemnt from a location (x,y).
        For the use of this function, re-visiting already visited locations is
        considred to be invalid and not allowable.
        
        Parameters
        ----------
        x: int
            X co-ordinate of the queried location
        y: int
            Y co-ordinate of the queried location
        
        Returns
        -------
        valid_actions: array
            An array containing all valid actions from the queried location given the current environment state.
        &#34;&#34;&#34;
        valid_actions = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x, new_y = x + dx, y + dy
                if (new_x, new_y) in self.environment and self.environment[(new_x, new_y)][0] == 0:
                    valid_actions.append((new_x, new_y))
        return valid_actions

    def brightest_adjacent_cell(self, cell):
        &#34;&#34;&#34;
        A utility to the searching algorithms.
        Identifies the brightest among the adjacent cells of a given cell.
        If the queried cell is brighter than all it&#39;s adjacent cells then 
        the queried cell location will be returned.
        
        Parameters
        ----------
        cell : Tuple
            (x,y) co ordinates of a queried location

        Returns
        -------
        brightest : Tuple.
            (x,y) co-ordinates of the brightest cell adjacent to the queried cell.
        &#34;&#34;&#34;
        brightest = (cell[0],cell[1])
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x, new_y = cell[0] + dx, cell[1] + dy
                if (new_x, new_y) in self.environment:
                    if self.environment[(new_x, new_y)][1] &gt; self.environment[brightest][1]:
                        brightest = (new_x, new_y)
        return brightest

    def depth_first_search(self, threshold):
        &#34;&#34;&#34;
        Perform a depth-first search of the environment.
        Frontier is used as a stack, or single ended queue in this instance.
        Algorithm takes the following steps:
            -Find valid actions at the current state.
            -Push these actions to the frontier.
            -Pop the top action from the frontier.
            -Call the transition function (move_to_point()) with the new action.
            -Cointinue until a specified threshold value is discovered.
        
        The way that valid actions are returned and pushed to the stack results in
        the agent preffering to travel diagonally to extreme points of the environment first.
        
        The search continues until one of the two conditions are met: 
            - A location with luminosity greater than the specified threshold has been found.
            - The entire environment has been searched.
            
        Parameters
        ----------
        threshold: int
            A threshold luminosity reading value to triger breaking out of the search.
            
        Returns
        -------
        None. Calls the transition function (move_to_point()) from within.
        &#34;&#34;&#34;
        self.set_lights(&#39;searching&#39;)
        
        self.frontier = []
        while self.max_lum &lt; threshold:
                
            self.print_grid()
            print(&#34;getting valid_actions&#34;)
            valid_actions = self.get_valid_actions(self.x, self.y)
            print(valid_actions)
            #input(&#34;Agent Paused, Press Enter to Carry on...&#34;)
            if valid_actions:
                print(&#34;Valid Actions Found, Updating Frontier&#34;)
                self.frontier.extend([action for action in valid_actions if action not in self.frontier])
            if self.frontier:
                print(f&#34;New Frontier: \n{self.frontier}&#34;)
                new_node = self.frontier.pop()
                self.move_to_point(new_node)
                self.update_agent_state()
            else:
                print(&#34;We would break the search here&#34;)
                #break

    def optimised_greedy_search(self):
        &#34;&#34;&#34;
        Perform a Greedy search exploration of the environemnt.
        At each step the agent moves in the direction that has the brightest location.
        Algorithm takes the following steps:
            -Given current search location (x,y) determine the valid actions.
            -Take each valid action and update the state variabls for each new state,action.
            -Once all adjacent cells have been visited, determine which adjacent cell to the search location is the brightest.
            -Travel to the brightest location and repreat.
            -If the curent search location is the brightest the terminal state has been reached
            -Set self.done = True
        
        This approach is optimised in the sense that it uses the known luminosity data of previously 
        visited cells to make informed decisions quickly, thus minimizing unnecessary exploration.

        Returns:
            None. Calls the transition function (move_to_point()) from within. Will directly set self.done to True.
        &#34;&#34;&#34;
        self.set_lights(&#39;localising&#39;)
        
        maximum = (self.x, self.y)
        
        while not self.done:
            self.print_grid()
            print(&#34;getting valid_actions&#34;)
            valid_actions = self.get_valid_actions(self.x, self.y)
            print(valid_actions)
            #input(&#34;Agent Will Visit adjecent Cells, Press Enter to Carry on...&#34;)
            for action in valid_actions:
                self.transition_function(action)
                self.print_grid()
            #input(&#34;Agent Will now compute the brightest adjacent cell and drive there, Press Enter to Carry on...&#34;)
            brightest = self.brightest_adjacent_cell(maximum)
            self.transition_function(brightest)
            if maximum == brightest:
                print(f&#34;Lamp found at {brightest} with luminosity {self.environment[brightest][1]}&#34;)
                self.done = True
            maximum = brightest

    def coverage(self):
        &#34;&#34;&#34;
        This is one of the top level callable search algorithms that the agent may employ.Executes a sweeping coverage of the environment in a snake-like, zigzag pattern to ensure all areas are visited.
        This method will set the self.done variable to True upon reaching the terminal state.
   
        Returns:
        None. The agent&#39;s state and the map of the environment are updated internally to reflect the progress of the search.
        &#34;&#34;&#34;
        self.set_lights(&#39;coverage&#39;)
        zigzag = True
        self.update_agent_state()
        while any(value[0] == 0 for value in self.environment.values()):
            self.print_grid()
            if zigzag:
                if self.y &lt; (self.bounds[1] / self.grid_size) - 1:
                    new_target = (self.x, self.y + 1)
                    print(&#34;moving North&#34;)
                elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                    new_target = (self.x + 1, self.y)
                    zigzag = False
                else:
                    print(&#34;Edge of the Universe.&#34;)
            else:
                if self.y &gt; 0:
                    new_target = (self.x, self.y - 1)
                    print(&#34;Moving South&#34;)
                elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                    new_target = (self.x + 1, self.y)
                    zigzag = True
                else:
                    print(&#34;Edge of the Universe.&#34;)
            self.transition_function(new_target)
        
        max_lum_location = max(self.environment, key=lambda k: self.environment[k][1])
        self.transition_function(max_lum_location)
        self.done = True

    def active_sensing(self, threshold = 100):
        &#34;&#34;&#34;
        Conducts an active sensing search of the environemnt.
        First conduction DFS until a threshhold luminosity is discovered.
        Then implements a greedy search to reach terminal state.
        Find the area of highest luminosity.
        
        Parameters
        ----------
        threshold : int
            
        
        &#34;&#34;&#34;
        self.update_agent_state()
        self.depth_first_search(threshold)
        print(f&#34;Greater than {threshold} found, switching to active sensing&#34;)
        self.optimised_greedy_search()    

    def data_log(self):
        &#34;&#34;&#34;
        Logs the agent&#39;s position, luminosity, and time step to a file.
        &#34;&#34;&#34;
        
        data = f&#34;{time.time_ns()}, {self.time_step}, {self.x}, {self.y}, {self.lum}\n&#34;
        with open(self.log_file, &#39;a&#39;) as file:
            file.write(data)

    def set_lights(self, style):
        &#34;&#34;&#34;
        A basic utility function to set the lights.
        Useful for instantaneous visul feedback of the agent&#39;s actions to an observer.
        
        Returns
        -------
        None. Directly sets the LED colours through the spheroV2 SDK.
        &#34;&#34;&#34;
        colours = {
            &#39;coverage&#39;: ((75, 0, 130),(0,0,0)),  # Purple
            &#39;searching&#39;: ((255, 140, 0),(0,0,0)), # Orange
            &#39;localising&#39;: ((0, 150, 0),(75,75,75)),  # Green
            &#39;party1&#39;: ((255, 0, 0),(0,0,255)),      # Red
            &#39;party2&#39;: ((0, 0, 255),(255,0,0))       # Blue
        }
        main_colour, small_colour = colours.get(style, ((0, 0, 0), (0, 0, 0)))

        self.droid.set_main_led(Color(main_colour[0], main_colour[1], main_colour[2]))
        self.droid.set_front_led(Color(small_colour[0], small_colour[1], small_colour[2]))
        self.droid.set_back_led(Color(small_colour[0], small_colour[1], small_colour[2]))

    def print_grid(self):
        &#34;&#34;&#34;
        Prints a visual representation of the grid environment, with blank squares for un-visited sites,
        and the measured luminosity for visited locations.
        Prints to the terminal using the maintained state variables
        
        returns
        -------
        none. Prints to the terminal.
        &#34;&#34;&#34;
        num_cells_x = self.bounds[0] // self.grid_size
        num_cells_y = self.bounds[1] // self.grid_size
    
        top_row = &#39; &#39; * 5 + &#39; &#39;.join(f&#39;{x:3d} &#39; for x in range(num_cells_x))
        print(top_row)
        horizontal_line = &#39; &#39; * 4 + &#39;+&#39; + (&#39;----+&#39; * num_cells_x)
        
        for y in reversed(range(num_cells_y)):
            print(horizontal_line)
            row = f&#39;{y:3d} |&#39;
            for x in range(num_cells_x):
                cell = (x, y)
                if self.environment.get(cell, (0, 0))[0] == 1:
                    brightness = int(self.environment[cell][1])
                    row += f&#39;{brightness:3d} |&#39;
                else:
                    row += &#39;    |&#39;
            print(row)
        print(horizontal_line)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MothAgent.MothAgent.active_sensing"><code class="name flex">
<span>def <span class="ident">active_sensing</span></span>(<span>self, threshold=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Conducts an active sensing search of the environemnt.
First conduction DFS until a threshhold luminosity is discovered.
Then implements a greedy search to reach terminal state.
Find the area of highest luminosity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def active_sensing(self, threshold = 100):
    &#34;&#34;&#34;
    Conducts an active sensing search of the environemnt.
    First conduction DFS until a threshhold luminosity is discovered.
    Then implements a greedy search to reach terminal state.
    Find the area of highest luminosity.
    
    Parameters
    ----------
    threshold : int
        
    
    &#34;&#34;&#34;
    self.update_agent_state()
    self.depth_first_search(threshold)
    print(f&#34;Greater than {threshold} found, switching to active sensing&#34;)
    self.optimised_greedy_search()    </code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.brightest_adjacent_cell"><code class="name flex">
<span>def <span class="ident">brightest_adjacent_cell</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>A utility to the searching algorithms.
Identifies the brightest among the adjacent cells of a given cell.
If the queried cell is brighter than all it's adjacent cells then
the queried cell location will be returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code>Tuple</code></dt>
<dd>(x,y) co ordinates of a queried location</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>brightest : Tuple.
(x,y) co-ordinates of the brightest cell adjacent to the queried cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brightest_adjacent_cell(self, cell):
    &#34;&#34;&#34;
    A utility to the searching algorithms.
    Identifies the brightest among the adjacent cells of a given cell.
    If the queried cell is brighter than all it&#39;s adjacent cells then 
    the queried cell location will be returned.
    
    Parameters
    ----------
    cell : Tuple
        (x,y) co ordinates of a queried location

    Returns
    -------
    brightest : Tuple.
        (x,y) co-ordinates of the brightest cell adjacent to the queried cell.
    &#34;&#34;&#34;
    brightest = (cell[0],cell[1])
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            new_x, new_y = cell[0] + dx, cell[1] + dy
            if (new_x, new_y) in self.environment:
                if self.environment[(new_x, new_y)][1] &gt; self.environment[brightest][1]:
                    brightest = (new_x, new_y)
    return brightest</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.coverage"><code class="name flex">
<span>def <span class="ident">coverage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is one of the top level callable search algorithms that the agent may employ.Executes a sweeping coverage of the environment in a snake-like, zigzag pattern to ensure all areas are visited.
This method will set the self.done variable to True upon reaching the terminal state.</p>
<p>Returns:
None. The agent's state and the map of the environment are updated internally to reflect the progress of the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coverage(self):
    &#34;&#34;&#34;
    This is one of the top level callable search algorithms that the agent may employ.Executes a sweeping coverage of the environment in a snake-like, zigzag pattern to ensure all areas are visited.
    This method will set the self.done variable to True upon reaching the terminal state.

    Returns:
    None. The agent&#39;s state and the map of the environment are updated internally to reflect the progress of the search.
    &#34;&#34;&#34;
    self.set_lights(&#39;coverage&#39;)
    zigzag = True
    self.update_agent_state()
    while any(value[0] == 0 for value in self.environment.values()):
        self.print_grid()
        if zigzag:
            if self.y &lt; (self.bounds[1] / self.grid_size) - 1:
                new_target = (self.x, self.y + 1)
                print(&#34;moving North&#34;)
            elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                new_target = (self.x + 1, self.y)
                zigzag = False
            else:
                print(&#34;Edge of the Universe.&#34;)
        else:
            if self.y &gt; 0:
                new_target = (self.x, self.y - 1)
                print(&#34;Moving South&#34;)
            elif self.x &lt; (self.bounds[0] / self.grid_size) - 1:
                new_target = (self.x + 1, self.y)
                zigzag = True
            else:
                print(&#34;Edge of the Universe.&#34;)
        self.transition_function(new_target)
    
    max_lum_location = max(self.environment, key=lambda k: self.environment[k][1])
    self.transition_function(max_lum_location)
    self.done = True</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.data_log"><code class="name flex">
<span>def <span class="ident">data_log</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs the agent's position, luminosity, and time step to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_log(self):
    &#34;&#34;&#34;
    Logs the agent&#39;s position, luminosity, and time step to a file.
    &#34;&#34;&#34;
    
    data = f&#34;{time.time_ns()}, {self.time_step}, {self.x}, {self.y}, {self.lum}\n&#34;
    with open(self.log_file, &#39;a&#39;) as file:
        file.write(data)</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.depth_first_search"><code class="name flex">
<span>def <span class="ident">depth_first_search</span></span>(<span>self, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a depth-first search of the environment.
Frontier is used as a stack, or single ended queue in this instance.
Algorithm takes the following steps:
-Find valid actions at the current state.
-Push these actions to the frontier.
-Pop the top action from the frontier.
-Call the transition function (move_to_point()) with the new action.
-Cointinue until a specified threshold value is discovered.</p>
<p>The way that valid actions are returned and pushed to the stack results in
the agent preffering to travel diagonally to extreme points of the environment first.</p>
<p>The search continues until one of the two conditions are met:
- A location with luminosity greater than the specified threshold has been found.
- The entire environment has been searched.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>A threshold luminosity reading value to triger breaking out of the search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. Calls the transition function (move_to_point()) from within.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth_first_search(self, threshold):
    &#34;&#34;&#34;
    Perform a depth-first search of the environment.
    Frontier is used as a stack, or single ended queue in this instance.
    Algorithm takes the following steps:
        -Find valid actions at the current state.
        -Push these actions to the frontier.
        -Pop the top action from the frontier.
        -Call the transition function (move_to_point()) with the new action.
        -Cointinue until a specified threshold value is discovered.
    
    The way that valid actions are returned and pushed to the stack results in
    the agent preffering to travel diagonally to extreme points of the environment first.
    
    The search continues until one of the two conditions are met: 
        - A location with luminosity greater than the specified threshold has been found.
        - The entire environment has been searched.
        
    Parameters
    ----------
    threshold: int
        A threshold luminosity reading value to triger breaking out of the search.
        
    Returns
    -------
    None. Calls the transition function (move_to_point()) from within.
    &#34;&#34;&#34;
    self.set_lights(&#39;searching&#39;)
    
    self.frontier = []
    while self.max_lum &lt; threshold:
            
        self.print_grid()
        print(&#34;getting valid_actions&#34;)
        valid_actions = self.get_valid_actions(self.x, self.y)
        print(valid_actions)
        #input(&#34;Agent Paused, Press Enter to Carry on...&#34;)
        if valid_actions:
            print(&#34;Valid Actions Found, Updating Frontier&#34;)
            self.frontier.extend([action for action in valid_actions if action not in self.frontier])
        if self.frontier:
            print(f&#34;New Frontier: \n{self.frontier}&#34;)
            new_node = self.frontier.pop()
            self.move_to_point(new_node)
            self.update_agent_state()
        else:
            print(&#34;We would break the search here&#34;)
            #break</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.get_lum"><code class="name flex">
<span>def <span class="ident">get_lum</span></span>(<span>self, retry_count=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Forms part of the transition function.
Measures and returns the average luminosity from multiple readings.
Handles potentially invalid readings through recursive calls.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>retry_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum allowable recursion depth when handling bad data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lum</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer value of the lum reading, or None in case of bad data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lum(self, retry_count=0):
    &#34;&#34;&#34;
    Forms part of the transition function.
    Measures and returns the average luminosity from multiple readings.
    Handles potentially invalid readings through recursive calls.
    
    Parameters
    ----------
    retry_count: int
        Maximum allowable recursion depth when handling bad data.
    
    Returns
    -------
    lum : int
        Integer value of the lum reading, or None in case of bad data
    &#34;&#34;&#34;
    if retry_count &gt;5:
        return None
    
    lum_readings = []
    for _ in range(10):
        lum_readings.append(self.droid.get_luminosity()[&#39;ambient_light&#39;])
        #self.droid.spin(36, 0.1)
        time.sleep(0.01)
    avg_lum = sum(lum_readings) // len(lum_readings)
    
    #Sphero BOLT likes to retun nonesense data, recursively call this function in case of nonsense.
    if avg_lum &lt; 0:
        time.sleep(0.5)
        avg_lum = self.get_lum(retry_count+1)
    return avg_lum</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.get_valid_actions"><code class="name flex">
<span>def <span class="ident">get_valid_actions</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>A utility to the searching algorithms.
Generates a set of possible allowable actions for navigation of the grid
environemnt from a location (x,y).
For the use of this function, re-visiting already visited locations is
considred to be invalid and not allowable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>X co-ordinate of the queried location</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Y co-ordinate of the queried location</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>valid_actions</code></strong> :&ensp;<code>array</code></dt>
<dd>An array containing all valid actions from the queried location given the current environment state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_actions(self, x, y):
    &#34;&#34;&#34;
    A utility to the searching algorithms.
    Generates a set of possible allowable actions for navigation of the grid
    environemnt from a location (x,y).
    For the use of this function, re-visiting already visited locations is
    considred to be invalid and not allowable.
    
    Parameters
    ----------
    x: int
        X co-ordinate of the queried location
    y: int
        Y co-ordinate of the queried location
    
    Returns
    -------
    valid_actions: array
        An array containing all valid actions from the queried location given the current environment state.
    &#34;&#34;&#34;
    valid_actions = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            new_x, new_y = x + dx, y + dy
            if (new_x, new_y) in self.environment and self.environment[(new_x, new_y)][0] == 0:
                valid_actions.append((new_x, new_y))
    return valid_actions</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.move_to_point"><code class="name flex">
<span>def <span class="ident">move_to_point</span></span>(<span>self, waypoint, max_time=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Part of the transition function of the agent.
Moves the agent to the specified grid point.
Updates the agents state variables upon reaching the new state.
Gracefully handles faulty data fed from the spherov2 SDK and Sphero BOLT robot acting as droid.
Will return false and "give up" after max_time seconds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_time</code></strong> :&ensp;<code>int (seconds)</code></dt>
<dd>Defaults to 15 - time after whcih the function will break and return false.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean. True if sucesfully reached the location, otherwise returns false to indicate a failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_point(self, waypoint, max_time=30):
    &#34;&#34;&#34;
    Part of the transition function of the agent.
    Moves the agent to the specified grid point.
    Updates the agents state variables upon reaching the new state.
    Gracefully handles faulty data fed from the spherov2 SDK and Sphero BOLT robot acting as droid.
    Will return false and &#34;give up&#34; after max_time seconds.
    
    Parameters
    ----------
    max_time: int (seconds)
        Defaults to 15 - time after whcih the function will break and return false.
    
    Returns
    -------
    Boolean. True if sucesfully reached the location, otherwise returns false to indicate a failure.
    &#34;&#34;&#34;
    target_x = (waypoint[0] * self.grid_size) + (self.grid_size * 0.5)
    target_y = (waypoint[1] * self.grid_size) + (self.grid_size * 0.5)
    
    #Retry counters for handling bad data from sphero
    retry_count = 0
    max_retries = 5
    
    #timers for preventing infinite hangups if the sphero gets stuck
    start = time.time()
    elapsed=time.time()
    
    while elapsed &lt; start + max_time: 
        elapsed=time.time()
        location = self.droid.get_location()
        x = location[&#39;x&#39;]
        y = location[&#39;y&#39;]
        if math.isnan(x) or math.isnan(y):
            if retry_count &lt; max_retries:
                time.sleep(0.5)
                retry_count += 1
                continue
            else:
                print(&#34;Failed to get valid location data after several retries.&#34;)
                return False

        dist_error = math.sqrt((x - target_x)**2 + (y - target_y)**2)
        theta_error = 180 * math.atan2(target_x - x, target_y - y) / math.pi
        self.droid.set_heading(int(theta_error))

        try:
            if dist_error &gt; 10:
                self.droid.set_speed(45)
            elif dist_error &lt; 5:
                self.droid.set_speed(0)
                return True
            else:
                self.droid.set_speed(int(dist_error) + 10)
            time.sleep(0.01)
        except ValueError as e:
            print(f&#34;Error in setting heading: {e}&#34;)
            return False
    return False</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.optimised_greedy_search"><code class="name flex">
<span>def <span class="ident">optimised_greedy_search</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a Greedy search exploration of the environemnt.
At each step the agent moves in the direction that has the brightest location.
Algorithm takes the following steps:
-Given current search location (x,y) determine the valid actions.
-Take each valid action and update the state variabls for each new state,action.
-Once all adjacent cells have been visited, determine which adjacent cell to the search location is the brightest.
-Travel to the brightest location and repreat.
-If the curent search location is the brightest the terminal state has been reached
-Set self.done = True</p>
<p>This approach is optimised in the sense that it uses the known luminosity data of previously
visited cells to make informed decisions quickly, thus minimizing unnecessary exploration.</p>
<h2 id="returns">Returns</h2>
<p>None. Calls the transition function (move_to_point()) from within. Will directly set self.done to True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimised_greedy_search(self):
    &#34;&#34;&#34;
    Perform a Greedy search exploration of the environemnt.
    At each step the agent moves in the direction that has the brightest location.
    Algorithm takes the following steps:
        -Given current search location (x,y) determine the valid actions.
        -Take each valid action and update the state variabls for each new state,action.
        -Once all adjacent cells have been visited, determine which adjacent cell to the search location is the brightest.
        -Travel to the brightest location and repreat.
        -If the curent search location is the brightest the terminal state has been reached
        -Set self.done = True
    
    This approach is optimised in the sense that it uses the known luminosity data of previously 
    visited cells to make informed decisions quickly, thus minimizing unnecessary exploration.

    Returns:
        None. Calls the transition function (move_to_point()) from within. Will directly set self.done to True.
    &#34;&#34;&#34;
    self.set_lights(&#39;localising&#39;)
    
    maximum = (self.x, self.y)
    
    while not self.done:
        self.print_grid()
        print(&#34;getting valid_actions&#34;)
        valid_actions = self.get_valid_actions(self.x, self.y)
        print(valid_actions)
        #input(&#34;Agent Will Visit adjecent Cells, Press Enter to Carry on...&#34;)
        for action in valid_actions:
            self.transition_function(action)
            self.print_grid()
        #input(&#34;Agent Will now compute the brightest adjacent cell and drive there, Press Enter to Carry on...&#34;)
        brightest = self.brightest_adjacent_cell(maximum)
        self.transition_function(brightest)
        if maximum == brightest:
            print(f&#34;Lamp found at {brightest} with luminosity {self.environment[brightest][1]}&#34;)
            self.done = True
        maximum = brightest</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.print_grid"><code class="name flex">
<span>def <span class="ident">print_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a visual representation of the grid environment, with blank squares for un-visited sites,
and the measured luminosity for visited locations.
Prints to the terminal using the maintained state variables</p>
<h2 id="returns">Returns</h2>
<p>none. Prints to the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_grid(self):
    &#34;&#34;&#34;
    Prints a visual representation of the grid environment, with blank squares for un-visited sites,
    and the measured luminosity for visited locations.
    Prints to the terminal using the maintained state variables
    
    returns
    -------
    none. Prints to the terminal.
    &#34;&#34;&#34;
    num_cells_x = self.bounds[0] // self.grid_size
    num_cells_y = self.bounds[1] // self.grid_size

    top_row = &#39; &#39; * 5 + &#39; &#39;.join(f&#39;{x:3d} &#39; for x in range(num_cells_x))
    print(top_row)
    horizontal_line = &#39; &#39; * 4 + &#39;+&#39; + (&#39;----+&#39; * num_cells_x)
    
    for y in reversed(range(num_cells_y)):
        print(horizontal_line)
        row = f&#39;{y:3d} |&#39;
        for x in range(num_cells_x):
            cell = (x, y)
            if self.environment.get(cell, (0, 0))[0] == 1:
                brightness = int(self.environment[cell][1])
                row += f&#39;{brightness:3d} |&#39;
            else:
                row += &#39;    |&#39;
        print(row)
    print(horizontal_line)</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.set_lights"><code class="name flex">
<span>def <span class="ident">set_lights</span></span>(<span>self, style)</span>
</code></dt>
<dd>
<div class="desc"><p>A basic utility function to set the lights.
Useful for instantaneous visul feedback of the agent's actions to an observer.</p>
<h2 id="returns">Returns</h2>
<p>None. Directly sets the LED colours through the spheroV2 SDK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_lights(self, style):
    &#34;&#34;&#34;
    A basic utility function to set the lights.
    Useful for instantaneous visul feedback of the agent&#39;s actions to an observer.
    
    Returns
    -------
    None. Directly sets the LED colours through the spheroV2 SDK.
    &#34;&#34;&#34;
    colours = {
        &#39;coverage&#39;: ((75, 0, 130),(0,0,0)),  # Purple
        &#39;searching&#39;: ((255, 140, 0),(0,0,0)), # Orange
        &#39;localising&#39;: ((0, 150, 0),(75,75,75)),  # Green
        &#39;party1&#39;: ((255, 0, 0),(0,0,255)),      # Red
        &#39;party2&#39;: ((0, 0, 255),(255,0,0))       # Blue
    }
    main_colour, small_colour = colours.get(style, ((0, 0, 0), (0, 0, 0)))

    self.droid.set_main_led(Color(main_colour[0], main_colour[1], main_colour[2]))
    self.droid.set_front_led(Color(small_colour[0], small_colour[1], small_colour[2]))
    self.droid.set_back_led(Color(small_colour[0], small_colour[1], small_colour[2]))</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.transition_function"><code class="name flex">
<span>def <span class="ident">transition_function</span></span>(<span>self, action, timeout=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the agenttransition function actions with a timeout mechanism
to prevent operations from hanging indefinitely.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The action ((x,y)location) - parameter to be passed to the move_to_point method.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int </code></dt>
<dd>Default = 15. The maximum time (in seconds) allowed for for transition before timing out.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>Exception: If the transition function failed to move or update state due to environmental factors.</p>
<h2 id="returns">Returns</h2>
<p>None. Calls functions to directly set state variables and move the droid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transition_function(self, action, timeout=15):
    &#34;&#34;&#34;
    Executes the agenttransition function actions with a timeout mechanism
    to prevent operations from hanging indefinitely.
    
    Parameters
    ----------
    action: tuple
        The action ((x,y)location) - parameter to be passed to the move_to_point method.
    timeout: int 
        Default = 15. The maximum time (in seconds) allowed for for transition before timing out.
    
    Raises
    ------
    Exception: If the transition function failed to move or update state due to environmental factors.
    
    Returns
    -------
    None. Calls functions to directly set state variables and move the droid.
    &#34;&#34;&#34;
    self.time_step += 1
    
    if not self.move_to_point(action, timeout):
        raise Exception(&#34;Error in transition function - unable to move to next state.&#34;)
    if not self.update_agent_state():
        raise Exception(&#34;Error in transition function - unable to update state variable.&#34;)</code></pre>
</details>
</dd>
<dt id="MothAgent.MothAgent.update_agent_state"><code class="name flex">
<span>def <span class="ident">update_agent_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Part of the transition function of the agent.
Directly updates the state variables: x, y, lum, environment, max_lum and brightest_loc.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Bool</code></strong></dt>
<dd>True if state was update successfully else false.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_agent_state(self):
    &#34;&#34;&#34; 
    Part of the transition function of the agent. 
    Directly updates the state variables: x, y, lum, environment, max_lum and brightest_loc.
    
    Returns
    -------
    Bool: 
        True if state was update successfully else false.
    &#34;&#34;&#34;
    new_lum = self.get_lum()
    if new_lum == None:
        return False
    self.lum = new_lum
    if self.lum &gt; (self.max_lum or 0):
        self.max_lum = self.lum
        self.brightest_loc = (self.x, self.y)
        
    self.x = int(self.droid.get_location()[&#39;x&#39;] / self.grid_size)
    self.y = int(self.droid.get_location()[&#39;y&#39;] / self.grid_size)
    self.environment[(self.x, self.y)] = (1, self.lum)

    self.data_log()
    
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MothAgent.MothAgent" href="#MothAgent.MothAgent">MothAgent</a></code></h4>
<ul class="">
<li><code><a title="MothAgent.MothAgent.active_sensing" href="#MothAgent.MothAgent.active_sensing">active_sensing</a></code></li>
<li><code><a title="MothAgent.MothAgent.brightest_adjacent_cell" href="#MothAgent.MothAgent.brightest_adjacent_cell">brightest_adjacent_cell</a></code></li>
<li><code><a title="MothAgent.MothAgent.coverage" href="#MothAgent.MothAgent.coverage">coverage</a></code></li>
<li><code><a title="MothAgent.MothAgent.data_log" href="#MothAgent.MothAgent.data_log">data_log</a></code></li>
<li><code><a title="MothAgent.MothAgent.depth_first_search" href="#MothAgent.MothAgent.depth_first_search">depth_first_search</a></code></li>
<li><code><a title="MothAgent.MothAgent.get_lum" href="#MothAgent.MothAgent.get_lum">get_lum</a></code></li>
<li><code><a title="MothAgent.MothAgent.get_valid_actions" href="#MothAgent.MothAgent.get_valid_actions">get_valid_actions</a></code></li>
<li><code><a title="MothAgent.MothAgent.move_to_point" href="#MothAgent.MothAgent.move_to_point">move_to_point</a></code></li>
<li><code><a title="MothAgent.MothAgent.optimised_greedy_search" href="#MothAgent.MothAgent.optimised_greedy_search">optimised_greedy_search</a></code></li>
<li><code><a title="MothAgent.MothAgent.print_grid" href="#MothAgent.MothAgent.print_grid">print_grid</a></code></li>
<li><code><a title="MothAgent.MothAgent.set_lights" href="#MothAgent.MothAgent.set_lights">set_lights</a></code></li>
<li><code><a title="MothAgent.MothAgent.transition_function" href="#MothAgent.MothAgent.transition_function">transition_function</a></code></li>
<li><code><a title="MothAgent.MothAgent.update_agent_state" href="#MothAgent.MothAgent.update_agent_state">update_agent_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>